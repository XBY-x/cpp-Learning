# Notes

## 指针

### const 修饰指针

记忆方法： 指针常量(指针是常量)  ； 常量指针(常量的指针)。 

​                    const 修饰谁，谁就不能更改

#### 常量指针

- 指针的指向**可以**修改，指针指向的指**不可以**修改

  ``` cpp
  int a = 10;
  int b = 20;
  const int *p = &a;
  /*可以*/     p = &b; 
  /*不可以*/// *p = 20；
  ```

  

#### 指针常量

- 指针的指向**不可以**修改，指针指向的值**可以**修改

  ``` cpp
  int a = 10;
  int b = 20;
  int * const p = &a;
  /*不可以*///  p = &b; 
  /*可以*/     *p = 20；
  ```



#### const 即修饰指针，又修饰常量

- 指针的指向**不可以**修改，指针指向的值**不可以**修改

  ``` cpp
  int a = 10;
  int b = 20;
  int * const p = &a;
  /*不可以*///  p = &b; 
  /*不可以*/// *p = 20；
  ```



## C++核心编程

本阶段主要对c++面向对象详细讲解

### 1. 内存分区模型

执行程序时，**4个区域**

- 代码区： 存放函数体的二进制代码，由操作系统进行管理
- 全局区：存放 全局变量、静态变量 和 常量
- 栈区：    由编译器自动分配和释放，存放函数的参数值、局部变量等
- 堆区：    由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。

**意义**：不同区域存放的数据，赋予不同生命周期，更灵活





#### 1.1 程序运行前

程序编译后生成可执行文件，未执行该可执行程序前，分为两个区域:

##### 代码区

- 存放CPU执行的机器指令

- 代码区是**共享**的：内存中只有一份代码即可

- 代码区是**只读**的

- 理解:

  代码区 是一张贴墙上的告示，谁都可以看(共享)，但是谁都不能改(只读)。

  共享是为了一张告示让谁都可以看见要做什么，而不需要给每个人都发一封私信告知(减少多次运行消耗)；

  只读是为了防止别人篡改(安全与防止误操作)

##### 全局区

- 包含

  - **全局变量** 

  - **静态变量** (static)

  - **常量区**： 

    - **字符串常量**

    - **其他常量** - (const修饰的**全局变量**) 

      [**注意**] ==const修饰的局部变量 **不在** 全局区==

- 该区域数据 在程序结束后，==由操作系统释放==



#### 1.2 程序运行后

##### 栈区

- 编译器自动分配释放
- 存放: **局部变量** 、 **函数形参** 



##### 堆区

- 程序员分配释放，若程序员不释放，程序结束时由操作系统回收
- 用**new**关键字开辟内存

```cpp
#include <iostream>
int * func()  
{
    //指针p 是局部变量，放在栈上。指针指向的new出来的地址(存放着数据10)，是放在堆区的
    int *p = new int(10);
    return *p;
}
int main()
{
    //ptr 执行func中在堆区new的地址
    int *ptr = func();
    return 0;
}
```



#### 1.3 new 操作符

- new 在堆区开辟数据，返回该数据对应类型的指针
- delete 释放
- `new 数据类型`
- 注意 delete数组时，需要加 []



``` cpp
int * func()
{
    //new 返回该数据对应类型的指针
    
    //new一个int空间，存个整型数 5 
    int * p_num = new int(5);
    //delete 它
    delete p_num;
    
    //new一个长度为10的int数组空间，返回首地址
    int * arr =  new int[10];
    for(int i=0; i<10; i++)
    {
        arr[i] = i+100； 
    }
    
    //释放数组，需要加[]
    delete[] arr;
    
}
```







### 2. 引用

#### 2.1 引用的基本使用

**作用**：给变量起别名

**语法**： `数据类型 &别名 = 原名`

#### 2.2 引用注意事项

- 引用**必须初始化**

- 引用在初始化后，**不可以**改变它所绑定的变量

  

  ``` cpp
  int a = 10;
  int &b = a;  //引用必须初始化 之后也不能改，这一步就把 b 和 a 绑死了
  ```

  



#### 2.3 引用做函数参数

**作用**：函数传参时，可以利用引用让形参修饰实参 （更安全、开销小）

**优点**：简化指针修改实参

``` cpp
//引用传递
void test_func(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp
}
int main()
{
    int m_a = 10;
    int m_b = 20;
    test_func(m_a, m_b);
    
    return 0;
}
```







#### 2.4 引用做函数返回值(特定情况下)

引用可以做为函数的返回值

**注意**： **不可以**返回局部变量的引用

用法： 如果函数的返回值是引用，则这个函数调用作为左值。 (换言之，如果函数做左值，那函数的返回值必须是引用)

``` cpp
int& test()
{
    static int a = 20;  //静态变量 - 存放在 全局区
    int b = 30;         //局部变量 - 存放在 栈区
    return a;
}

int main()
{
    int& ref2 = test();
    cout << "[1]ref2 is " << ref2 << endl;
    cout << "[2]ref2 is " << ref2 << endl;
    
    test() = 123; //此时 test() 是 a的引用(函数返回值就是个引用)，所以可以被赋值
    
    cout << "[3]ref2 is " << ref2 << endl;
    cout << "[4]ref2 is " << ref2 << endl;

    return 0;
}
/*  output：
 *  [1]ref2 is 20
 *  [2]ref2 is 20
 *  [3]ref2 is 123
 *  [4]ref2 is 123
*/
```



#### 2.5 引用的本质 - 指针常量

==引用在C++内部实现是一个**指针常量**==

``` c++
int a = 10;

int& ref = a;  //自动转换为 int * const ref = &a; 
               //指针常量 的 指针指向不可修改 (所以引用不可更改)
ref = 20;      //内部发现ref是引用，自动转换为: *ref = 20；

```





#### 2.6 常量引用

**作用**：常量引用**const 修饰形参**，防止误操作 (禁止函数内部修改)

``` cpp
void showValue(const int& v)  
{
    cout << v << endl;
}
```



**其它**

```cpp
//[非法操作-不能给一个数起别名] int & ref = 10;
```

```cpp
const int & ref = 10; 
//上面的语句 被编译器转换为: 
int temp = 10;  const int & ref = temp;   //也就相当于 const int * const ref = temp
//此时ref只读，不可修改
```





### 3. 函数提高

#### 3.1 函数默认参数

在 C++中，函数的形参列表中的形参 可以有默认值

语法: `返回值类型 函数名 (参数= 默认值) { 函数体; }`



##### **注意事项**： 

1. **默认实参必须在形参列表的结尾** （有默认参数之后的 都必须有默认参数）

```cpp
//有默认实参
int func_1(int a, int b=20, int c=30)
{
    return a + b + c;
}
//无默认实参
int func_2(int a, int b, int c)
{
    return a + b + c;
}
int main()
{
    int sum_1 = func_1(10);  //有默认实参，可以缺省有实参的参数
    int sum_2 = func_2(10, 20, 30);
    int sum_3 = func_1(10, 50, 60); //此时没有缺省，使用实际传入的值
    return 0;
}
```



2. **函数声明 和 函数实现 只能有一个有默认参数**

``` cpp
//函数声明
int test_a(int a, int b=20, int c=30)；
//函数定义
int test_a(int a, int b, int c)
{
    return a + b + c;
}

[或者]

//函数声明
int test_b(int a, int b, int c)；
//函数定义
int test_b(int a, int b=20, int c=30)
{
    return a + b + c;
}
```





#### 3.2 函数占位参数

递增运算符重载会用到占位函数

https://www.bilibili.com/video/BV1et411b73Z?p=96&spm_id_from=pageDriver





#### 3.3 函数重载

##### 3.3.1 函数重载概述

##### 3.3.2 函数重载注意事项







### 4. 类和对象



### 5. 文件操作































# 参考课程 - bilibili

https://www.bilibili.com/video/BV1et411b73Z?p=84